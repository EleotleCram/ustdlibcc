////////////////////////////////////////////////////////////////////////////////
//
// (c) 2014 redi at gnu dot org
//
//	Boost Software License - Version 1.0 - August 17, 2003
//
//	Permission is hereby granted, free of charge, to any person or organization
//	obtaining a copy of the software and accompanying documentation covered by
//	this license (the "Software") to use, reproduce, display, distribute,
//	execute, and transmit the Software, and to prepare derivative works of the
//	Software, and to permit third-parties to whom the Software is furnished to
//	do so, all subject to the following:
//
//	The copyright notices in the Software and this entire statement, including
//	the above license grant, this restriction and the following disclaimer,
//	must be included in all copies of the Software, in whole or in part, and
//	all derivative works of the Software, unless such copies or derivative
//	works are solely in the form of machine-executable object code generated by
//	a source language processor.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//	DEALINGS IN THE SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////////

#include <new>

namespace std{

template<typename Signature>
class function;

template<typename R, typename... Args>
class function<R(Args...)>
{
	struct function_base
	{
		virtual ~function_base() = default;

		virtual R call(Args&... args) const = 0;

		virtual function_base* clone() const = 0;
	};

	template<typename R2, typename F>
		struct function_impl : function_base
		{
			function_impl(F&& f)
			: f(static_cast<F&&>(f)) { }

			virtual R call(Args&... args) const
			{ return f(static_cast<Args&&>(args)...); }

			virtual function_base* clone() const
			{ return new function_impl(*this); }

			F f;
		};

	template<typename F>
		struct function_impl<void, F> : function_base
		{
			function_impl(F&& f)
			: f(static_cast<F&&>(f)) { }

			virtual void call(Args&... args) const
			{ f(static_cast<Args&&>(args)...); }

			virtual function_base* clone() const
			{ return new function_impl(*this); }

			F f;
		};


public:
	template<typename F>
		function(F f)
		: impl(new function_impl<R, F>(static_cast<F&&>(f))) { }

	function(const function& f) : impl(f.impl ? impl->clone() : nullptr) { }

	function(function&& f) : impl(f.impl) { f.impl = nullptr; }

	~function() { delete impl; }

	function&
	operator=(const function& f)
	{
		if (f.impl)
		{
			auto copy = f.impl->clone();
			delete impl;
			impl = copy;
		}
		else
			impl = nullptr;
		return *this;
	}

	function&
	operator=(function&& f)
	{
		delete impl;
		impl = f.impl;
		f.impl = nullptr;
		return *this;
	}

	R operator()(Args... args) const { return impl->call(args...); }

private:
	function_base* impl = nullptr;
};

} // namespace std
