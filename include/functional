////////////////////////////////////////////////////////////////////////////////
//
// (c) 2014 redi at gnu dot org
//
//	Boost Software License - Version 1.0 - August 17, 2003
//
//	Permission is hereby granted, free of charge, to any person or organization
//	obtaining a copy of the software and accompanying documentation covered by
//	this license (the "Software") to use, reproduce, display, distribute,
//	execute, and transmit the Software, and to prepare derivative works of the
//	Software, and to permit third-parties to whom the Software is furnished to
//	do so, all subject to the following:
//
//	The copyright notices in the Software and this entire statement, including
//	the above license grant, this restriction and the following disclaimer,
//	must be included in all copies of the Software, in whole or in part, and
//	all derivative works of the Software, unless such copies or derivative
//	works are solely in the form of machine-executable object code generated by
//	a source language processor.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//	DEALINGS IN THE SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////////

#include <new>

namespace std{

#include <stddef.h>

void* operator new(size_t, void* p) { return p; }

template<typename Signature>
class function;

template<typename R, typename... Args>
class function<R(Args...)>
{
	struct function_base
	{
		virtual ~function_base() = default;

		virtual R call(Args&... args) const = 0;

		virtual function_base* clone(void*) const = 0;

		virtual void destroy() { delete this; }
	};

	static constexpr size_t bufsize = sizeof(void*) * 2;

	template<typename R2, typename F,
					 bool = (sizeof(F) <= bufsize) && __is_trivially_copyable(F)>
		struct function_impl : function_base
		{
			function_impl(F& f)
			: f(static_cast<F&&>(f)) { }

			virtual R call(Args&... args) const
			{ return f(static_cast<Args&&>(args)...); }

			virtual function_base* clone(void*) const
			{ return new function_impl(*this); }

			static function_base* create(F& f, void*)
			{ return new function_impl(f); }

			F f;
		};

	template<typename F>
		struct function_impl<void, F, false> : function_base
		{
			function_impl(F& f)
			: f(static_cast<F&&>(f)) { }

			virtual void call(Args&... args) const
			{ f(static_cast<Args&&>(args)...); }

			virtual function_base* clone(void*) const
			{ return new function_impl(*this); }

			static function_base* create(F& f, void*)
			{ return new function_impl(f); }

			F f;
		};

	template<typename R2, typename F>
		struct function_impl<R2, F, true> : function_base
		{
			function_impl(F& f)
			: f(static_cast<F&&>(f)) { }

			virtual R call(Args&... args) const
			{ return f(static_cast<Args&&>(args)...); }

			virtual function_base* clone(void* p) const
			{ return ::new(p) function_impl(*this); }

			virtual void destroy() { this->~function_impl(); }

			static function_base* create(F& f, void* p)
			{ return ::new(p) function_impl(f); }

			F f;
		};

	template<typename F>
		struct function_impl<void, F, true> : function_base
		{
			function_impl(F& f)
			: f(static_cast<F&&>(f)) { }

			virtual void call(Args&... args) const
			{ f(static_cast<Args&&>(args)...); }

			virtual function_base* clone(void* p) const
			{ return ::new(p) function_impl(*this); }

			virtual void destroy() { this->~function_impl(); }

			static function_base* create(F& f, void* p)
			{ return ::new(p) function_impl(f); }

			F f;
		};


public:
	template<typename F>
		function(F f)
		: impl(function_impl<R, F>::create(f, buf)) { }

	function(const function& f) : impl(f.impl ? impl->clone(buf) : nullptr) { }

	~function() { if (impl) impl->destroy(); }

	function&
	operator=(const function& f)
	{
		if (f.impl)
		{
			auto copy = impl->clone(buf);
			impl->destroy();
			impl = copy;
		}
		else
			impl = nullptr;
		return *this;
	}

	R operator()(Args... args) const { return impl->call(args...); }

private:
	function_base* impl;

	union {
		char buf[bufsize];
		void* p;
		void (*fp)();
		void (function::*pmf)();
	};
};

} // namespace std
